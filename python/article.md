# Automatically Generating Swagger Specifications with Python

The first time I was introduced to swagger was a couple of years ago when I had to implement a system monitoring app using the nutanix REST API. I found it a really convenient way to debug and document web services.
Later, when asked to provide documentation for a different project, I took to swagger and started implementing a specification. Like most of today's webservices, the API endpoints for this project provided CRUD functionality: create, read, update, delete operations to a database backend.
A lot of the information that needed to be described in the specification was already implicitly coded into the application, so instead of manually writing down the spec, I decided to generate it using the available application semantics.

This was a python project using the flask-restful REST implementation with the SQLAlchemy ORM, so the idea was to extract database object schemas from the SQLAlchemy class declarations and the flask-restful endpoint definitions to generate the swagger specification.
This worked out very well and I’ve since improved the implementation and functionality and made the project available as an open source python-pip package: [safrs](https://github.com/thomaxxl/safrs). safrs is an acronym for the main technologies used: SqlAlchemy, Flask-Restful & Swagger.

I have created a small [example script](https://github.com/thomaxxl/safrs/blob/master/examples/demo_relationship.py) To demonstrate the package's functionality (A running version of the example can be found [here](http://thomaxxl.pythonanywhere.com/api/))
Running this script will expose two classes (Users and Books) as REST endpoints. The User class definition looks like this:

```python
class User(SAFRSBase, db.Model):
    '''
        description: User description
    '''
    __tablename__ = 'Users'
    id = Column(String, primary_key=True)
    name = Column(String, default='')
    email = Column(String, default='')
    books = db.relationship('Book', back_populates="user", lazy='dynamic')
```

This class will automatically produce a swagger specification and [jsonapi](http://jsonapi.org/)-compliant endpoints:
![users](images/users1.PNG)

The software can also detect and expose database relationships, the “books” relationship defined in the User class from the example creates following endpoints

![books](images/books.PNG)

The JSON data expected by the API will also be automatically generated by using a sample object instance:

![usersPOST](images/usersPOST.PNG)

It's also possible for developers to describe additional swagger specification details as 
yaml-encoded comments (eg. the "description" key in the User class will be parsed and used as the description in the UI).

More features and examples can be found on the project's [github page](https://github.com/thomaxxl/safrs).

Besides the benefits of having a swagger specification available for your project, using the safrs approach has a number of additional advantages:
- The swagger specification is always consistent with the implementation.
- There's less manual work involved in creating and maintaining the specification. 
- The API is compliant with the [jsonapi](http://jsonapi.org/) standard.

Since the number of JSON webservices will continue to grow, I believe standardization, visibility, compartmentalization and automation
is increasingly important in managing the complexity of modern software microservice architectures and that's why technologies like swagger 
and safrs may bring a lot value.

